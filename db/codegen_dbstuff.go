//go:build debug

package yodb

import (
	"bytes"
	"go/format"
	"io/fs"
	"path/filepath"
	"reflect"

	q "yo/db/query"
	yolog "yo/log"
	. "yo/util"
	"yo/util/str"
)

const (
	codegenEmitTopCommentLine = "// Code generated by `yo/db/codegen_dbstuff.go`. DO NOT EDIT\n"
)

func init() {
	if IsDevMode {
		codegenDBStuff = func() {
			yolog.Println("codegen (db stuff)")
			if !IsDevMode {
				return
			}
			by_pkg_path := map[string][]*structDesc{}
			for _, desc := range ensureDescs {
				pkg_path := desc.ty.PkgPath()
				by_pkg_path[pkg_path] = append(by_pkg_path[pkg_path], desc)
			}
			did_code_gen := codegenQueryFns()
			for pkg_path, descs := range by_pkg_path {
				did_code_gen = (codegenDBStructsFor(pkg_path, descs)) || did_code_gen
			}
			if did_code_gen {
				panic("dbcodegen'd, please restart")
			}
		}
	}
}

func codegenDBStructsFor(pkgPath string, descs []*structDesc) bool {
	var src_dir_path, pkg_name string
	for _, desc := range descs { // find src_dir_path in which to generate `ˍcodegend.go`
		found, needle := str.Dict{}, []byte("\ntype "+desc.ty.Name()+" struct {\n\t")

		is_yo_own := (str.Begins(desc.ty.PkgPath(), "yo/") || (desc.ty.PkgPath() == "yo"))
		WalkCodeFiles(is_yo_own, !is_yo_own, func(path string, dirEntry fs.DirEntry) {
			if str.Ends(path, ".go") {
				data := ReadFile(path)
				if dir_path, idx := filepath.Dir(path), bytes.Index(data, needle); idx > 0 {
					if idx = bytes.IndexByte(data, '\n'); (idx < len("package ")) || !bytes.Equal(data[0:len("package ")], []byte("package ")) {
						panic("no package name for " + pkgPath)
					}
					pkg_name = str.Trim(string(data[len("package "):idx]))
					found[dir_path] = path
				}
			}
		},
		)
		//no source dir found for haxsh/app.User
		if len(found) == 0 {
			panic("no source dir found for " + desc.ty.PkgPath() + "." + desc.ty.Name())
		} else if len(found) > 1 {
			panic("too many source dirs found for " + desc.ty.PkgPath() + "." + desc.ty.Name())
		}
		for src_dir_path = range found {
			break
		}
	}
	if src_dir_path == "" {
		panic("no source dir found for " + pkgPath)
	}

	out_file_path := filepath.Join(src_dir_path, "ˍdbstructs_generated_code.go")
	if len(descs) == 0 {
		if IsFile(out_file_path) {
			DelFile(out_file_path)
			return true
		} else {
			return false
		}
	}

	var buf str.Buf
	buf.WriteString(codegenEmitTopCommentLine)
	buf.WriteString("package ")
	buf.WriteString(pkg_name)
	buf.WriteString("\n\nimport q \"yo/db/query\"\n\n")
	for _, desc := range descs {
		codegenWriteEnumDecl(&buf, desc)

		for i, rt_fld := 0, reflect.TypeOf(q.F("")); i < rt_fld.NumMethod(); i++ {
			if method := rt_fld.Method(i); (method.Name[0] >= 'A') && (method.Name[0] <= 'Z') {
				codegenCloneMethod(&buf, desc, &method)
			}
		}
	}

	raw_src, err := format.Source([]byte(buf.String()))
	if err != nil {
		panic(err)
	}

	if !bytes.Equal(ReadFile(out_file_path), raw_src) {
		WriteFile(out_file_path, raw_src)
		return true
	}
	return false
}

func codegenQueryFns() bool {
	src_raw := ReadFile("../yo/db/query/q.go")

	var buf bytes.Buffer
	buf.WriteString("package q\n")
	for _, line := range str.Split(str.Trim(string(src_raw)), "\n") {
		if pref := "\tFn"; (line != "") && str.Begins(line, pref) && str.Ends(line, `"`) && str.Has(line, ` fn = "`) {
			name := line[len(pref):str.Idx(line, ' ')]
			for _, operand_type_name := range []string{"C", "F", "V"} {
				buf.WriteString("\nfunc(me ")
				buf.WriteString(operand_type_name)
				buf.WriteByte(')')
				buf.WriteString(name)
				buf.WriteString(`(args...any)Operand{return Fn(Fn` + name + `,append([]any{me},args...)...)}`)
			}
		}
	}
	out_file_path := "../yo/db/query/ˍgenerated_code.go"
	src_old, src_new := ReadFile(out_file_path), buf.Bytes()
	if src_new, _ = format.Source(src_new); !bytes.Equal(src_old, src_new) {
		WriteFile(out_file_path, src_new)
		return true
	}
	return false
}

func codegenCloneMethod(buf *str.Buf, desc *structDesc, method *reflect.Method) {
	buf.WriteString("func(me ")
	buf.WriteString(desc.ty.Name())
	buf.WriteString("Field) ")
	buf.WriteString(method.Name)
	buf.WriteByte('(')
	for j, rt_fn := 1, method.Func.Type(); j < rt_fn.NumIn(); j++ {
		buf.WriteByte('a')
		buf.WriteString(str.FromInt(j))
		buf.WriteByte(' ')
		if rt_arg := rt_fn.In(j); (j == (rt_fn.NumIn() - 1)) && rt_fn.IsVariadic() {
			buf.WriteString("...")
			buf.WriteString(rt_arg.Elem().String())
		} else {
			buf.WriteString(rt_arg.String())
		}
		buf.WriteByte(',')
	}
	buf.WriteByte(')')
	buf.WriteByte('(')
	for j, rt_fn := 0, method.Func.Type(); j < rt_fn.NumOut(); j++ {
		buf.WriteString(rt_fn.Out(j).String())
	}
	buf.WriteByte(')')
	buf.WriteString("{return ((q.F)(me)).")
	buf.WriteString(method.Name)
	buf.WriteByte('(')
	for j, rt_fn := 1, method.Func.Type(); j < rt_fn.NumIn(); j++ {
		buf.WriteByte('a')
		buf.WriteString(str.FromInt(j))
		if (j == (rt_fn.NumIn() - 1)) && rt_fn.IsVariadic() {
			buf.WriteString("...")
		}
		buf.WriteByte(',')
	}
	buf.WriteByte(')')
	buf.WriteString("}\n")
}

func codegenWriteEnumDecl(buf *str.Buf, desc *structDesc) {
	type_name_suffix := "Field"
	buf.WriteString("type ")
	buf.WriteString(desc.ty.Name())
	buf.WriteString(type_name_suffix)
	buf.WriteString(" q.F\n\n")
	buf.WriteString("const (\n")
	var ref_fields []Pair[q.F, *structDesc]

	for _, field_name := range desc.fields {
		field, _ := desc.ty.FieldByName(string(field_name))
		if ref_of_type := isDbRefType(field.Type); "" != ref_of_type {
			var sub_desc *structDesc
			for _, desc := range descs {
				if ty_ident := desc.ty.PkgPath() + "." + desc.ty.Name(); ty_ident == ref_of_type {
					sub_desc = desc
					break
				}
			}
			if sub_desc == nil {
				panic(str.Fmt("un-`Ensure`d type '%s' ref'd by '%s'.'%s'  ", ref_of_type, desc.ty.String(), field_name))
			}
			ref_fields = append(ref_fields, Pair[q.F, *structDesc]{field_name, sub_desc})
		}
	}

	for _, field_name := range desc.fields {
		buf.WriteByte('\t')
		if !str.IsLo(string(field_name[:1])) {
			buf.WriteString(desc.ty.Name())
		} else {
			buf.WriteString(str.Lo(desc.ty.Name()[:1]))
			buf.WriteString(desc.ty.Name()[1:])
		}
		buf.WriteString(str.Up(string(field_name[:1])))
		buf.WriteString(string(field_name[1:]))
		buf.WriteString(" ")
		buf.WriteString(desc.ty.Name())
		buf.WriteString(type_name_suffix)
		buf.WriteString(" = \"")
		buf.WriteString(string(field_name))
		buf.WriteString("\"\n")
	}
	for _, ref_field := range ref_fields {
		field_name := ref_field.Key
		for _, sub_field := range ref_field.It.fields {
			buf.WriteByte('\t')
			if !str.IsLo(string(sub_field[:1])) {
				buf.WriteString(desc.ty.Name())
			} else {
				buf.WriteString(str.Lo(desc.ty.Name()[:1]))
				buf.WriteString(desc.ty.Name()[1:])
			}
			buf.WriteString(type_name_suffix)
			buf.WriteString(str.Up(string(field_name[:1])))
			buf.WriteString(string(field_name[1:]))
			buf.WriteByte('_')
			buf.WriteString(string(sub_field))
			buf.WriteString(" ")
			buf.WriteString(desc.ty.Name())
			buf.WriteString(type_name_suffix)
			buf.WriteString(" = \"")
			buf.WriteString(string(field_name))
			buf.WriteByte('.')
			buf.WriteString(string(sub_field))
			buf.WriteString("\"\n")
		}
	}
	buf.WriteString(")\n\n")
}
