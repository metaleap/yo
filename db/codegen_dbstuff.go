//go:build debug

package yodb

import (
	"bytes"
	"go/format"
	"io/fs"
	"path/filepath"
	"reflect"

	q "yo/db/query"
	yolog "yo/log"
	. "yo/util"
	"yo/util/str"
)

func init() {
	if IsDevMode {
		codeGenDBStuff = func() {
			yolog.Println("codegen (db stuff)...")
			if !IsDevMode {
				return
			}
			by_pkg_path := map[string][]*structDesc{}
			for _, desc := range ensureDescs {
				pkg_path := desc.ty.PkgPath()
				by_pkg_path[pkg_path] = append(by_pkg_path[pkg_path], desc)
			}
			did_code_gen := codeGenQueryFns()
			for pkg_path, descs := range by_pkg_path {
				did_code_gen = (codeGenDBStructsFor(pkg_path, descs)) || did_code_gen
			}
			if did_code_gen {
				panic("dbcodegen'd, please restart")
			}
		}
	}
}

func codeGenDBStructsFor(pkgPath string, descs []*structDesc) bool {
	var src_dir_path, pkg_name string
	for _, desc := range descs { // find src_dir_path in which to generate `ˍcodegend.go`
		found, needle := str.Dict{}, []byte("\ntype "+desc.ty.Name()+" struct {\n\t")

		is_yo_own := (str.Begins(desc.ty.PkgPath(), "yo/") || (desc.ty.PkgPath() == "yo"))
		WalkCodeFiles(is_yo_own, !is_yo_own, func(path string, dirEntry fs.DirEntry) {
			if str.Ends(path, ".go") {
				data := ReadFile(path)
				if dir_path, idx := filepath.Dir(path), bytes.Index(data, needle); idx > 0 {
					if idx = bytes.IndexByte(data, '\n'); (idx < len("package ")) || !bytes.Equal(data[0:len("package ")], []byte("package ")) {
						panic("no package name for " + pkgPath)
					}
					pkg_name = str.Trim(string(data[len("package "):idx]))
					found[dir_path] = path
				}
			}
		},
		)
		//no source dir found for haxsh/app.User
		if len(found) == 0 {
			panic("no source dir found for " + desc.ty.PkgPath() + "." + desc.ty.Name())
		} else if len(found) > 1 {
			panic("too many source dirs found for " + desc.ty.PkgPath() + "." + desc.ty.Name())
		}
		for src_dir_path = range found {
			break
		}
	}
	if src_dir_path == "" {
		panic("no source dir found for " + pkgPath)
	}

	out_file_path := filepath.Join(src_dir_path, "ˍdbstructs_generated_code.go")
	if len(descs) == 0 {
		if IsFile(out_file_path) {
			DelFile(out_file_path)
			return true
		} else {
			return false
		}
	}

	var buf str.Buf
	buf.WriteString("// Code generated by `yo/db/codegen_dbstructs.go`. DO NOT EDIT\n")
	buf.WriteString("package ")
	buf.WriteString(pkg_name)
	buf.WriteString("\n\nimport q \"yo/db/query\"\n\n")
	for _, desc := range descs {
		// render enumerants for the column names
		codeGenWriteEnumDecl(&buf, desc, "Col", "q.C", true)
		// render enumerants for the field names
		codeGenWriteEnumDecl(&buf, desc, "Field", "q.F", false)

		for i, rt_fld := 0, reflect.TypeOf(q.F("")); i < rt_fld.NumMethod(); i++ {
			if method := rt_fld.Method(i); (method.Name[0] >= 'A') && (method.Name[0] <= 'Z') {
				codeGenCloneMethod(&buf, desc, &method)
			}
		}
	}

	raw_src, err := format.Source([]byte(buf.String()))
	if err != nil {
		panic(err)
	}

	if !bytes.Equal(ReadFile(out_file_path), raw_src) {
		WriteFile(out_file_path, raw_src)
		return true
	}
	return false
}

func codeGenQueryFns() bool {
	src_raw := ReadFile("../yo/db/query/q.go")

	var buf bytes.Buffer
	buf.WriteString("package q\n")
	for _, line := range str.Split(str.Trim(string(src_raw)), "\n") {
		if pref := "\tFn"; (line != "") && str.Begins(line, pref) && str.Ends(line, `"`) && str.Has(line, ` fn = "`) {
			name := line[len(pref):str.Idx(line, ' ')]
			for _, operand_type_name := range []string{"C", "F", "V"} {
				buf.WriteString("\nfunc(me ")
				buf.WriteString(operand_type_name)
				buf.WriteByte(')')
				buf.WriteString(name)
				buf.WriteString(`(args...any)Operand{return Fn(Fn` + name + `,append([]any{me},args...)...)}`)
			}
		}
	}
	out_file_path := "../yo/db/query/ˍgenerated_code.go"
	src_old, src_new := ReadFile(out_file_path), buf.Bytes()
	if src_new, _ = format.Source(src_new); !bytes.Equal(src_old, src_new) {
		WriteFile(out_file_path, src_new)
		return true
	}
	return false
}

func codeGenCloneMethod(buf *str.Buf, desc *structDesc, method *reflect.Method) {
	buf.WriteString("func(me ")
	buf.WriteString(desc.ty.Name())
	buf.WriteString("Field) ")
	buf.WriteString(method.Name)
	buf.WriteByte('(')
	for j, rt_fn := 1, method.Func.Type(); j < rt_fn.NumIn(); j++ {
		buf.WriteByte('a')
		buf.WriteString(str.FromInt(j))
		buf.WriteByte(' ')
		if rt_arg := rt_fn.In(j); (j == (rt_fn.NumIn() - 1)) && rt_fn.IsVariadic() {
			buf.WriteString("...")
			buf.WriteString(rt_arg.Elem().String())
		} else {
			buf.WriteString(rt_arg.String())
		}
		buf.WriteByte(',')
	}
	buf.WriteByte(')')
	buf.WriteByte('(')
	for j, rt_fn := 0, method.Func.Type(); j < rt_fn.NumOut(); j++ {
		buf.WriteString(rt_fn.Out(j).String())
	}
	buf.WriteByte(')')
	buf.WriteString("{return ((q.F)(me)).")
	buf.WriteString(method.Name)
	buf.WriteByte('(')
	for j, rt_fn := 1, method.Func.Type(); j < rt_fn.NumIn(); j++ {
		buf.WriteByte('a')
		buf.WriteString(str.FromInt(j))
		if (j == (rt_fn.NumIn() - 1)) && rt_fn.IsVariadic() {
			buf.WriteString("...")
		}
		buf.WriteByte(',')
	}
	buf.WriteByte(')')
	buf.WriteString("}\n")
}

func codeGenWriteEnumDecl(buf *str.Buf, desc *structDesc, name string, goTypeAliasOf string, isForCols bool) {
	buf.WriteString("type ")
	buf.WriteString(desc.ty.Name())
	buf.WriteString(name)
	buf.WriteString(If(isForCols, " = ", " "))
	buf.WriteString(goTypeAliasOf)
	buf.WriteString("\n\n")
	buf.WriteString("const (\n")
	for i, col_name := range desc.cols {
		field_name := desc.fields[i]
		buf.WriteByte('\t')
		if isForCols || !str.IsLo(string(field_name[:1])) {
			buf.WriteString(desc.ty.Name())
		} else {
			buf.WriteString(str.Lo(desc.ty.Name()[:1]))
			buf.WriteString(desc.ty.Name()[1:])
		}
		buf.WriteString(name)
		buf.WriteString(str.Up(string(desc.fields[i][:1])))
		buf.WriteString(string(desc.fields[i][1:]))
		if !isForCols {
			buf.WriteString(" ")
			buf.WriteString(desc.ty.Name())
			buf.WriteString(name)
		}
		buf.WriteString(" = ")
		if isForCols {
			buf.WriteString(desc.ty.Name())
			buf.WriteString(name)
			buf.WriteString("(\"")
			buf.WriteString(string(col_name))
			buf.WriteString("\")\n")
		} else {
			buf.WriteString("\"")
			buf.WriteString(string(field_name))
			buf.WriteString("\"\n")
		}
	}
	buf.WriteString(")\n\n")
}
