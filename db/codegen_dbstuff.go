//go:build debug

package yodb

import (
	"bytes"
	"go/format"
	"io/fs"
	"path/filepath"
	"reflect"

	q "yo/db/query"
	yolog "yo/log"
	. "yo/util"
	"yo/util/sl"
	"yo/util/str"
)

const (
	codegenEmitTopCommentLine = "// Code generated by `yo/db/codegen_dbstuff.go`. DO NOT EDIT\n"
)

func init() {
	if IsDevMode {
		codegenDBStuff = func() {
			yolog.Println("codegen (db stuff)")
			if !IsDevMode {
				return
			}
			by_pkg_path := map[string][]*structDesc{}
			for _, desc := range ensureDescs {
				pkg_path := desc.ty.PkgPath()
				by_pkg_path[pkg_path] = append(by_pkg_path[pkg_path], desc)
			}
			did_code_gen := codegenDbPkgOwn()
			for pkg_path, descs := range by_pkg_path {
				did_code_gen = (codegenDBStructsFor(pkg_path, descs)) || did_code_gen
			}
			if did_code_gen {
				panic("dbcodegen'd, please restart")
			}
		}
	}
}

func codegenDBStructsFor(pkgPath string, descs []*structDesc) bool {
	var src_dir_path, pkg_name string
	for _, desc := range descs { // find src_dir_path in which to emit `ˍgenerated_dbstuff.go`
		found, needle := str.Dict{}, []byte("\ntype "+desc.ty.Name()+" struct {\n\t")

		is_yo_own := (str.Begins(desc.ty.PkgPath(), "yo/") || (desc.ty.PkgPath() == "yo"))
		WalkCodeFiles(is_yo_own, !is_yo_own, func(path string, dirEntry fs.DirEntry) {
			if str.Ends(path, ".go") {
				data := ReadFile(path)
				if dir_path, idx := filepath.Dir(path), bytes.Index(data, needle); idx > 0 {
					if idx = bytes.IndexByte(data, '\n'); (idx < len("package ")) || !bytes.Equal(data[0:len("package ")], []byte("package ")) {
						panic("no package name for " + pkgPath)
					}
					pkg_name = str.Trim(string(data[len("package "):idx]))
					found[dir_path] = path
				}
			}
		},
		)
		//no source dir found for haxsh/app.User
		if len(found) == 0 {
			panic("no source dir found for " + desc.ty.PkgPath() + "." + desc.ty.Name())
		} else if len(found) > 1 {
			panic("too many source dirs found for " + desc.ty.PkgPath() + "." + desc.ty.Name())
		}
		for src_dir_path = range found {
			break
		}
	}
	if src_dir_path == "" {
		panic("no source dir found for " + pkgPath)
	}

	out_file_path := filepath.Join(src_dir_path, "ˍgenerated_dbstuff.go")
	if len(descs) == 0 {
		if IsFile(out_file_path) {
			DelFile(out_file_path)
			return true
		} else {
			return false
		}
	}

	var buf str.Buf
	buf.WriteString(codegenEmitTopCommentLine)
	buf.WriteString("package ")
	buf.WriteString(pkg_name)
	buf.WriteString("\n\nimport q \"yo/db/query\"\n\n")
	for _, desc := range descs {
		codegenWriteEnumDecl(&buf, desc)
		codegenCloneMethods(&buf, desc.ty.Name()+"Field", "q", reflect.TypeOf(q.F("")), false)
	}

	raw_src, err := format.Source([]byte(buf.String()))
	if err != nil {
		panic(err)
	}

	if !bytes.Equal(ReadFile(out_file_path), raw_src) {
		WriteFile(out_file_path, raw_src)
		return true
	}
	return false
}

func codegenDbPkgOwn() (didEmit bool) {
	{
		out_file_path := "../yo/db/query/ˍgenerated_dbstuff.go"
		src_raw := ReadFile("../yo/db/query/q.go")
		var buf bytes.Buffer
		buf.WriteString("package q\n")
		for _, line := range str.Split(str.Trim(string(src_raw)), "\n") {
			if pref := "\tFn"; (line != "") && str.Begins(line, pref) &&
				(str.Ends(line, `"`) || str.Has(line, "\" //")) && str.Has(line, ` fn = "`) {
				name := line[len(pref):str.Idx(line, ' ')]
				for _, operand_type_name := range []string{"C", "F", "V"} {
					buf.WriteString("\nfunc(me ")
					buf.WriteString(operand_type_name)
					buf.WriteByte(')')
					buf.WriteString(name)
					buf.WriteString(`(args...any)Operand{return Fn(Fn` + name + `,append([]any{me},args...)...)}`)
				}
			}
		}
		src_old, src_new := ReadFile(out_file_path), buf.Bytes()
		if src_fmt, err := format.Source(src_new); (err != nil) || !bytes.Equal(src_old, src_fmt) {
			WriteFile(out_file_path, If(len(src_fmt) == 0, src_new, src_fmt))
			didEmit = true
		}
	}
	{
		out_file_path := "../yo/db/ˍgenerated_dbstuff.go"
		var buf str.Buf
		buf.WriteString("package " + yodbPkg.PkgName() + "\n")
		buf.WriteString("import sl \"yo/util/sl\"\n")
		for _, arr_type_name := range []string{"JsonArr[T]", "Arr[T]"} {
			codegenCloneMethods(&buf, arr_type_name, "sl", reflect.TypeOf(sl.Slice[map[Void]Void]{}), true)
		}

		src_old, src_new := ReadFile(out_file_path), []byte(str.Replace(buf.String(), str.Dict{"map[util.Void]util.Void": "T", "map[yo/util.Void]yo/util.Void": "T"}))
		if src_fmt, err := format.Source(src_new); (err != nil) || !bytes.Equal(src_old, src_fmt) {
			WriteFile(out_file_path, If(len(src_fmt) == 0, src_new, src_fmt))
			didEmit = true
		}
	}
	return
}

func codegenCloneMethods(buf *str.Buf, typeNameReceiver string, pkgName string, ty reflect.Type, inclPtrMethods bool) {
	type_name_underlying := pkgName + "." + ty.Name()
	methods_generated := map[string]bool{}
	for i := 0; i < ty.NumMethod(); i++ {
		if method := ty.Method(i); (method.Name[0] >= 'A') && (method.Name[0] <= 'Z') {
			codegenCloneMethod(buf, typeNameReceiver, type_name_underlying, &method)
			methods_generated[method.Name] = true
		}
	}
	if inclPtrMethods {
		ty = reflect.PointerTo(ty)
		type_name_underlying = "*" + pkgName + "." + ty.Elem().Name()
		for i := 0; i < ty.NumMethod(); i++ {
			if method := ty.Method(i); (method.Name[0] >= 'A') && (method.Name[0] <= 'Z') && !methods_generated[method.Name] {
				codegenCloneMethod(buf, "*"+typeNameReceiver, type_name_underlying, &method)
			}
		}
	}
}

func codegenCloneMethod(buf *str.Buf, typeNameReceiver string, typeNameUnderlying string, method *reflect.Method) {
	buf.WriteString("func(me ")
	buf.WriteString(typeNameReceiver)
	buf.WriteString(") ")
	buf.WriteString(method.Name)
	buf.WriteByte('(')
	for j, rt_fn := 1, method.Func.Type(); j < rt_fn.NumIn(); j++ {
		buf.WriteByte('a')
		buf.WriteString(str.FromInt(j))
		buf.WriteByte(' ')
		if rt_arg := rt_fn.In(j); (j == (rt_fn.NumIn() - 1)) && rt_fn.IsVariadic() {
			buf.WriteString("...")
			buf.WriteString(rt_arg.Elem().String())
		} else {
			buf.WriteString(rt_arg.String())
		}
		buf.WriteByte(',')
	}
	buf.WriteByte(')')
	buf.WriteByte('(')
	rt_fn := method.Func.Type()
	for j := 0; j < rt_fn.NumOut(); j++ {
		buf.WriteString(rt_fn.Out(j).String())
	}
	buf.WriteByte(')')
	buf.WriteString("{" + If(rt_fn.NumOut() == 0, "", "return") + " ((" + typeNameUnderlying + ")(me)).")
	buf.WriteString(method.Name)
	buf.WriteByte('(')
	for j, rt_fn := 1, method.Func.Type(); j < rt_fn.NumIn(); j++ {
		buf.WriteByte('a')
		buf.WriteString(str.FromInt(j))
		if (j == (rt_fn.NumIn() - 1)) && rt_fn.IsVariadic() {
			buf.WriteString("...")
		}
		buf.WriteByte(',')
	}
	buf.WriteByte(')')
	buf.WriteString("}\n")
}

func codegenWriteEnumDecl(buf *str.Buf, desc *structDesc) {
	type_name_suffix := "Field"
	buf.WriteString("type ")
	buf.WriteString(desc.ty.Name())
	buf.WriteString(type_name_suffix)
	buf.WriteString(" q.F\n\n")
	buf.WriteString("const (\n")
	var ref_fields []Pair[q.F, *structDesc]

	for _, field_name := range desc.fields {
		field, _ := desc.ty.FieldByName(string(field_name))
		if ref_of_type := dbRefType(field.Type); "" != ref_of_type {
			var sub_desc *structDesc
			for _, desc := range descs {
				if ty_ident := desc.ty.PkgPath() + "." + desc.ty.Name(); ty_ident == ref_of_type {
					sub_desc = desc
					break
				}
			}
			if sub_desc == nil {
				panic(str.Fmt("un-`Ensure`d type '%s' ref'd by '%s'.'%s'  ", ref_of_type, desc.ty.String(), field_name))
			}
			ref_fields = append(ref_fields, Pair[q.F, *structDesc]{field_name, sub_desc})
		}
	}

	for _, field_name := range desc.fields {
		buf.WriteByte('\t')
		if !str.IsLo(string(field_name[:1])) {
			buf.WriteString(desc.ty.Name())
		} else {
			buf.WriteString(str.Lo(desc.ty.Name()[:1]))
			buf.WriteString(desc.ty.Name()[1:])
		}
		buf.WriteString(str.Up(string(field_name[:1])))
		buf.WriteString(string(field_name[1:]))
		buf.WriteString(" ")
		buf.WriteString(desc.ty.Name())
		buf.WriteString(type_name_suffix)
		buf.WriteString(" = \"")
		buf.WriteString(string(field_name))
		buf.WriteString("\"\n")
	}
	for _, ref_field := range ref_fields {
		field_name := ref_field.Key
		for _, sub_field := range ref_field.It.fields {
			buf.WriteByte('\t')
			if !str.IsLo(string(sub_field[:1])) {
				buf.WriteString(desc.ty.Name())
			} else {
				buf.WriteString(str.Lo(desc.ty.Name()[:1]))
				buf.WriteString(desc.ty.Name()[1:])
			}
			buf.WriteString(str.Up(string(field_name[:1])))
			buf.WriteString(string(field_name[1:]))
			buf.WriteByte('_')
			buf.WriteString(string(sub_field))
			buf.WriteString(" ")
			buf.WriteString(desc.ty.Name())
			buf.WriteString(type_name_suffix)
			buf.WriteString(" = \"")
			buf.WriteString(string(field_name))
			buf.WriteByte('.')
			buf.WriteString(string(sub_field))
			buf.WriteString("\"\n")
		}
	}
	buf.WriteString(")\n\n")
}
